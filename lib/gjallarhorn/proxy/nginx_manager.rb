# frozen_string_literal: true

require "English"
require_relative "manager"

module Gjallarhorn
  module Proxy
    # Nginx proxy manager for zero-downtime deployments
    #
    # Manages nginx configuration updates and reloads to enable
    # zero-downtime deployments by switching upstream servers.
    #
    # @since 0.1.0
    class NginxManager < Manager
      # Default nginx configuration paths
      DEFAULT_NGINX_CONF_DIR = "/etc/nginx/conf.d"
      DEFAULT_NGINX_BIN = "nginx"

      # Initialize nginx proxy manager
      #
      # @param config [Hash] Nginx configuration
      # @param logger [Logger] Logger instance
      def initialize(config, logger = nil)
        super
        @nginx_conf_dir = config[:conf_dir] || DEFAULT_NGINX_CONF_DIR
        @nginx_bin = config[:nginx_bin] || DEFAULT_NGINX_BIN
        @domain = config[:domain] || config[:host]
        @ssl_enabled = config[:ssl] || false
        @app_port = config[:app_port] || 3000
      end

      # Switch traffic from old containers to new container
      #
      # @param service_name [String] Service name
      # @param from_containers [Array<Hash>] Containers to switch traffic from (unused in nginx implementation)
      # @param to_container [Hash] Container to switch traffic to
      # @return [void]
      def switch_traffic(service_name:, to_container:, from_containers: nil)
        @logger.info "Switching nginx traffic for #{service_name} to #{to_container[:name]}"

        # Generate new nginx configuration
        new_config = generate_service_config(service_name, [to_container])

        # Write configuration to file
        write_nginx_config(service_name, new_config)

        # Test nginx configuration
        test_nginx_config

        # Reload nginx gracefully
        reload_nginx

        # Verify traffic is flowing to new container
        if verify_traffic_switch(service_name, to_container)
          @logger.info "Successfully switched traffic to #{to_container[:name]}"
        else
          @logger.warn "Traffic switch completed but verification failed"
        end
      rescue StandardError => e
        @logger.error "Failed to switch nginx traffic: #{e.message}"
        raise ProxyError, "Nginx traffic switch failed: #{e.message}"
      end

      # Get nginx proxy status
      #
      # @return [Hash] Nginx status information
      def status
        {
          type: "nginx",
          status: nginx_running? ? "running" : "stopped",
          config_dir: @nginx_conf_dir,
          upstreams: configured_upstreams,
          last_reload: last_reload_time
        }
      end

      # Restart nginx service
      #
      # @return [Boolean] True if restart successful
      def restart
        @logger.info "Restarting nginx..."

        begin
          execute_nginx_command("restart")
          @logger.info "Nginx restarted successfully"
          true
        rescue StandardError => e
          @logger.error "Failed to restart nginx: #{e.message}"
          false
        end
      end

      # Check if nginx is healthy
      #
      # @return [Boolean] True if nginx is responding
      def healthy?
        nginx_running? && config_syntax_valid?
      end

      private

      # Generate nginx configuration for a service
      #
      # @param service_name [String] Service name
      # @param containers [Array<Hash>] Container information
      # @return [String] Nginx configuration
      def generate_service_config(service_name, containers)
        upstream_config = generate_upstream_config(service_name, containers)
        server_config = generate_server_config(service_name)

        <<~NGINX
          # Generated by Gjallarhorn for #{service_name}
          # Generated at: #{Time.now.utc.iso8601}

          #{upstream_config}

          #{server_config}
        NGINX
      end

      # Generate nginx server configuration block
      #
      # @param service_name [String] Service name
      # @return [String] Server configuration block
      def generate_server_config(service_name)
        ssl_config = generate_ssl_config
        security_headers = generate_security_headers
        health_check_config = generate_health_check_config(service_name)
        location_config = generate_location_config(service_name)

        <<~SERVER
          server {
              listen 80;
              #{ssl_config}
              server_name #{@domain};

              #{security_headers}

              #{health_check_config}

              #{location_config}
          }
        SERVER
      end

      # Generate health check configuration
      #
      # @param service_name [String] Service name
      # @return [String] Health check location block
      def generate_health_check_config(service_name)
        health_path = @config[:health_check_path] || "/health"

        <<~HEALTH
          # Health check endpoint with container identification
          location #{health_path} {
              proxy_pass http://#{service_name}#{health_path};
              proxy_set_header Host $host;
              proxy_set_header X-Real-IP $remote_addr;
              proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
              proxy_set_header X-Forwarded-Proto $scheme;
          #{"    "}
              # Add headers for traffic verification
              add_header X-Proxy-Backend $upstream_addr always;
              add_header X-Proxy-Status $upstream_status always;
          }
        HEALTH
      end

      # Write nginx configuration to file
      #
      # @param service_name [String] Service name
      # @param config_content [String] Configuration content
      # @return [String] Path to written configuration file
      def write_nginx_config(service_name, config_content)
        config_file = File.join(@nginx_conf_dir, "gjallarhorn-#{service_name}.conf")

        # Create backup of existing config if it exists
        if File.exist?(config_file)
          backup_file = "#{config_file}.backup-#{Time.now.strftime("%Y%m%d-%H%M%S")}"
          FileUtils.cp(config_file, backup_file)
          @logger.debug "Backed up existing config to #{backup_file}"
        end

        # Write new configuration
        File.write(config_file, config_content)
        @logger.debug "Wrote nginx config to #{config_file}"

        config_file
      end

      # Test nginx configuration syntax
      #
      # @raise [ProxyError] If configuration is invalid
      # @return [void]
      def test_nginx_config
        @logger.debug "Testing nginx configuration syntax..."

        result = execute_nginx_command("configtest")
        raise ProxyError, "Invalid nginx configuration: #{result[:error]}" unless result[:success]

        @logger.debug "Nginx configuration syntax is valid"
      end

      # Reload nginx gracefully
      #
      # @raise [ProxyError] If reload fails
      # @return [void]
      def reload_nginx
        @logger.info "Reloading nginx configuration..."

        result = execute_nginx_command("reload")
        raise ProxyError, "Failed to reload nginx: #{result[:error]}" unless result[:success]

        @logger.info "Nginx reloaded successfully"
      end

      # Execute nginx command
      #
      # @param action [String] Action to perform (reload, restart, configtest)
      # @return [Hash] Execution result
      def execute_nginx_command(action)
        case action
        when "reload"
          command = "#{@nginx_bin} -s reload"
        when "restart"
          command = "systemctl restart nginx"
        when "configtest"
          command = "#{@nginx_bin} -t"
        else
          raise ArgumentError, "Unknown nginx action: #{action}"
        end

        @logger.debug "Executing: #{command}"

        result = system(command)
        {
          success: result,
          error: result ? nil : "Command failed with exit code: #{$CHILD_STATUS.exitstatus}"
        }
      end

      # Check if nginx is running
      #
      # @return [Boolean] True if nginx process is running
      def nginx_running?
        system("pgrep nginx > /dev/null 2>&1")
      end

      # Check if nginx configuration syntax is valid
      #
      # @return [Boolean] True if configuration is valid
      def config_syntax_valid?
        result = execute_nginx_command("configtest")
        result[:success]
      end

      # Get configured upstream servers
      #
      # @return [Array<String>] List of configured upstreams
      def configured_upstreams
        config_files = Dir.glob(File.join(@nginx_conf_dir, "gjallarhorn-*.conf"))
        upstreams = []

        config_files.each do |file|
          content = File.read(file)
          upstreams.concat(content.scan(/upstream\s+(\w+)\s*{/).flatten)
        end

        upstreams
      end

      # Get last nginx reload time
      #
      # @return [Time, nil] Last reload time or nil if unknown
      def last_reload_time
        # Try to get nginx master process start time as proxy for last reload
        if nginx_running?
          pid = `pgrep -f "nginx: master process"`.strip
          unless pid.empty?
            stat_file = "/proc/#{pid}/stat"
            if File.exist?(stat_file)
              boot_time = File.read("/proc/stat").match(/btime (\d+)/)[1].to_i
              start_time_ticks = File.read(stat_file).split[21].to_i
              clock_ticks = 100 # Typical value for USER_HZ
              Time.at(boot_time + start_time_ticks / clock_ticks)
            end
          end
        end
      rescue StandardError
        nil
      end

      # Generate SSL configuration block
      #
      # @return [String] SSL configuration
      def generate_ssl_config
        return "" unless @ssl_enabled

        <<~SSL
          listen 443 ssl http2;
          ssl_certificate /etc/letsencrypt/live/#{@domain}/fullchain.pem;
          ssl_certificate_key /etc/letsencrypt/live/#{@domain}/privkey.pem;
          ssl_session_timeout 1d;
          ssl_session_cache shared:SSL:50m;
          ssl_stapling on;
          ssl_stapling_verify on;
        SSL
      end

      # Generate security headers configuration
      #
      # @return [String] Security headers configuration
      def generate_security_headers
        <<~HEADERS
          # Security headers
          add_header X-Frame-Options DENY always;
          add_header X-Content-Type-Options nosniff always;
          add_header X-XSS-Protection "1; mode=block" always;
          add_header Referrer-Policy "strict-origin-when-cross-origin" always;

          # Gjallarhorn identification headers
          add_header X-Proxy-Type "nginx" always;
          add_header X-Managed-By "gjallarhorn" always;
        HEADERS
      end

      # Generate location configuration for main proxy
      #
      # @param service_name [String] Service name
      # @return [String] Location configuration
      def generate_location_config(service_name)
        <<~LOCATION
          location / {
              proxy_pass http://#{service_name};
              proxy_set_header Host $host;
              proxy_set_header X-Real-IP $remote_addr;
              proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
              proxy_set_header X-Forwarded-Proto $scheme;
              proxy_set_header X-Forwarded-Host $host;
              proxy_set_header X-Forwarded-Port $server_port;
          #{"    "}
              # Timeouts
              proxy_connect_timeout 5s;
              proxy_send_timeout 60s;
              proxy_read_timeout 60s;
          #{"    "}
              # Buffer settings
              proxy_buffering on;
              proxy_buffer_size 4k;
              proxy_buffers 8 4k;
          #{"    "}
              # Health check support
              proxy_next_upstream error timeout http_502 http_503 http_504;
          }
        LOCATION
      end
    end

    # Raised when proxy operations fail
    class ProxyError < Error; end
  end
end
